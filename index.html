if (category) {
    await updateDoc(doc(db, 'projectTypes', categoryId), { name, subcategories });
    await addDoc(collection(db, 'activityLog'), {
        action: `Updated category: ${name}`,
        user: state.currentUser.name,
        timestamp: Date.now()
    });
} else {
    await addDoc(collection(db, 'projectTypes'), { name, subcategories });
    await addDoc(collection(db, 'activityLog'), {
        action: `Added category: ${name}`,
        user: state.currentUser.name,
        timestamp: Date.now()
    });
}
closeModal();
showNotification('Category saved successfully');
} catch (error) {
    console.error('Error saving category:', error);
    showNotification('Failed to save category', null, true);
}
};
}

function showPhaseForm(phase = null) {
const content = `
    <form id="phase-form">
        <div class="form-group">
            <label for="phase-name" class="required">Phase Name</label>
            <input type="text" id="phase-name" value="${phase || ''}" required>
        </div>
        <button type="submit" class="btn-primary">${phase ? 'Update' : 'Add'} Phase</button>
    </form>
`;
showModal(`${phase ? 'Edit' : 'Add'} Testing Phase`, content);
document.getElementById('phase-form').onsubmit = async (e) => {
    e.preventDefault();
    const name = document.getElementById('phase-name').value.trim();
    if (!name) {
        showNotification('Phase name is required', null, true);
        return;
    }
    try {
        if (phase) {
            const phaseIndex = state.testingPhases.indexOf(phase);
            state.testingPhases[phaseIndex] = name;
            await updateDoc(doc(db, 'testingPhases', 'phases'), { phases: state.testingPhases });
            await addDoc(collection(db, 'activityLog'), {
                action: `Updated phase: ${name}`,
                user: state.currentUser.name,
                timestamp: Date.now()
            });
        } else {
            state.testingPhases.push(name);
            await setDoc(doc(db, 'testingPhases', 'phases'), { phases: state.testingPhases });
            await addDoc(collection(db, 'activityLog'), {
                action: `Added phase: ${name}`,
                user: state.currentUser.name,
                timestamp: Date.now()
            });
        }
        closeModal();
        showNotification('Phase saved successfully');
    } catch (error) {
        console.error('Error saving phase:', error);
        showNotification('Failed to save phase', null, true);
    }
};
}

function renderProjectTypes() {
const typesList = document.getElementById('project-types-list');
typesList.innerHTML = '';
state.projectTypes.forEach(category => {
    const item = document.createElement('div');
    item.className = 'category-item';
    item.innerHTML = `
        <span>${category.name}</span>
        <div>
            <button class="btn-primary" onclick="showCategoryForm('${category.id}')">Edit</button>
            <button class="btn-danger" onclick="deleteCategory('${category.id}')">Delete</button>
        </div>
    `;
    typesList.appendChild(item);
    
    const subcategoryList = document.createElement('div');
    subcategoryList.className = 'subcategory-list';
    category.subcategories.forEach(sub => {
        const subItem = document.createElement('div');
        subItem.className = 'subcategory-item';
        subItem.innerHTML = `<span>${sub}</span>`;
        subcategoryList.appendChild(subItem);
    });
    typesList.appendChild(subcategoryList);
});

const phasesList = document.getElementById('testing-phases-list');
phasesList.innerHTML = '';
state.testingPhases.forEach(phase => {
    const item = document.createElement('div');
    item.className = 'list-item';
    item.innerHTML = `
        <span>${phase}</span>
        <div>
            <button class="btn-primary" onclick="showPhaseForm('${phase}')">Edit</button>
            <button class="btn-danger" onclick="deletePhase('${phase}')">Delete</button>
        </div>
    `;
    phasesList.appendChild(item);
});
}

async function deleteCategory(categoryId) {
try {
    await deleteDoc(doc(db, 'projectTypes', categoryId));
    await addDoc(collection(db, 'activityLog'), {
        action: 'Deleted category',
        user: state.currentUser.name,
        timestamp: Date.now()
    });
    showNotification('Category deleted successfully');
} catch (error) {
    console.error('Error deleting category:', error);
    showNotification('Failed to delete category', null, true);
}
}

async function deletePhase(phase) {
try {
    state.testingPhases = state.testingPhases.filter(p => p !== phase);
    await updateDoc(doc(db, 'testingPhases', 'phases'), { phases: state.testingPhases });
    await addDoc(collection(db, 'activityLog'), {
        action: `Deleted phase: ${phase}`,
        user: state.currentUser.name,
        timestamp: Date.now()
    });
    showNotification('Phase deleted successfully');
} catch (error) {
    console.error('Error deleting phase:', error);
    showNotification('Failed to delete phase', null, true);
}
}

function renderReports() {
const tbody = document.querySelector('#qa-report tbody');
tbody.innerHTML = '';
const dateFilter = document.getElementById('report-filter-date').value;
const qaFilter = document.getElementById('report-filter-qa').value;
const projectFilter = document.getElementById('report-filter-project').value;
const typeFilter = document.getElementById('report-filter-type').value;

let filteredProjects = state.projectOverview;
if (dateFilter) filteredProjects = filteredProjects.filter(p => p.startDate === dateFilter);
if (qaFilter) filteredProjects = filteredProjects.filter(p => p.qaId === qaFilter);
if (projectFilter) filteredProjects = filteredProjects.filter(p => p.projectName === projectFilter);
if (typeFilter) filteredProjects = filteredProjects.filter(p => p.projectType === typeFilter);

filteredProjects.forEach(project => {
    const qa = state.users.find(u => u.id === project.qaId);
    const row = document.createElement('tr');
    row.innerHTML = `
        <td>${project.projectName}</td>
        <td>${qa ? qa.name : 'Unassigned'}</td>
        <td>${project.projectType}</td>
        <td>${project.currentPhase}</td>
        <td>${project.status}</td>
        <td>${project.approvedForLive}</td>
    `;
    tbody.appendChild(row);
});

const qaSelect = document.getElementById('report-filter-qa');
qaSelect.innerHTML = '<option value="">All QAs</option>' + 
    state.users.filter(u => u.role === 'QA Member').map(u => `<option value="${u.id}">${u.name}</option>`).join('');

const projectSelect = document.getElementById('report-filter-project');
projectSelect.innerHTML = '<option value="">All Projects</option>' + 
    state.projectOverview.map(p => `<option value="${p.projectName}">${p.projectName}</option>`).join('');

const typeSelect = document.getElementById('report-filter-type');
typeSelect.innerHTML = '<option value="">All Types</option>' + 
    [...new Set(state.projectOverview.map(p => p.projectType))].map(t => `<option value="${t}">${t}</option>`).join('');
}

function exportReport() {
const tbody = document.querySelector('#qa-report tbody');
const rows = Array.from(tbody.querySelectorAll('tr'));
const csv = [
    ['Project Name', 'QA', 'Type', 'Phase', 'Status', 'Approved?'],
    ...rows.map(row => Array.from(row.cells).map(cell => cell.textContent))
].map(row => row.join(',')).join('\n');
const blob = new Blob([csv], { type: 'text/csv' });
const url = window.URL.createObjectURL(blob);
const a = document.createElement('a');
a.setAttribute('href', url);
a.setAttribute('download', `qa_report_${new Date().toISOString().split('T')[0]}.csv`);
a.click();
window.URL.revokeObjectURL(url);
addDoc(collection(db, 'activityLog'), {
    action: 'Exported QA report',
    user: state.currentUser.name,
    timestamp: Date.now()
});
showNotification('Report exported successfully');
}

function renderActivityLog() {
const list = document.getElementById('activity-log-list');
list.innerHTML = '';
state.activityLog.sort((a, b) => b.timestamp - a.timestamp).forEach(log => {
    const item = document.createElement('div');
    item.className = 'list-item';
    item.innerHTML = `<span>${new Date(log.timestamp).toLocaleString()} - ${log.user}: ${log.action}</span>`;
    list.appendChild(item);
});
}

function renderProfile() {
document.getElementById('profile-name').value = state.currentUser.name;
document.getElementById('profile-email').value = state.currentUser.email;
document.getElementById('profile-email').disabled = true;
}

async function updateProfile() {
const name = document.getElementById('profile-name').value.trim();
const password = document.getElementById('profile-password').value;
if (!name) {
    showNotification('Name is required', null, true);
    return;
}
try {
    await updateDoc(doc(db, 'users', state.currentUser.id), { name });
    if (password) {
        await updatePassword(auth.currentUser, password);
    }
    state.currentUser.name = name;
    updateUserAvatar();
    await addDoc(collection(db, 'activityLog'), {
        action: `Updated profile${password ? ' and password' : ''}`,
        user: state.currentUser.name,
        timestamp: Date.now()
    });
    showNotification('Profile updated successfully');
} catch (error) {
    console.error('Error updating profile:', error);
    showNotification('Failed to update profile', null, true);
}
}

function showUserForm(userId = null) {
const user = userId ? state.users.find(u => u.id === userId) : null;
const content = `
    <form id="user-form">
        <div class="form-group">
            <label for="user-name" class="required">Name</label>
            <input type="text" id="user-name" value="${user ? user.name : ''}" required>
        </div>
        <div class="form-group">
            <label for="user-email" class="required">Email</label>
            <input type="email" id="user-email" value="${user ? user.email : ''}" ${user ? 'disabled' : ''} required>
        </div>
        <div class="form-group">
            <label for="user-password" class="required">Password</label>
            <input type="password" id="user-password" ${user ? 'placeholder="Leave blank to keep current password"' : 'required'}>
        </div>
        <div class="form-group">
            <label for="user-role" class="required">Role</label>
            <select id="user-role" required>
                <option value="QA Member" ${user && user.role === 'QA Member' ? 'selected' : ''}>QA Member</option>
                <option value="Team Lead" ${user && user.role === 'Team Lead' ? 'selected' : ''}>Team Lead</option>
                <option value="Admin" ${user && user.role === 'Admin' ? 'selected' : ''}>Admin</option>
            </select>
        </div>
        <button type="submit" class="btn-primary">${user ? 'Update' : 'Add'} User</button>
    </form>
`;
showModal(`${user ? 'Edit' : 'Add'} User`, content);
document.getElementById('user-form').onsubmit = async (e) => {
    e.preventDefault();
    const name = document.getElementById('user-name').value.trim();
    const email = document.getElementById('user-email').value.trim();
    const password = document.getElementById('user-password').value;
    const role = document.getElementById('user-role').value;
    if (!name || !email || (!user && !password) || !role) {
        showNotification('Please fill all required fields', null, true);
        return;
    }
    try {
        if (user) {
            await updateDoc(doc(db, 'users', userId), { name, role });
            if (password) {
                // Note: Password updates for existing users should be handled separately
                showNotification('Password updates must be done by the user', null, true);
            }
            await addDoc(collection(db, 'activityLog'), {
                action: `Updated user: ${name}`,
                user: state.currentUser.name,
                timestamp: Date.now()
            });
        } else {
            const userCredential = await createUserWithEmailAndPassword(auth, email, password);
            await setDoc(doc(db, 'users', userCredential.user.uid), {
                name,
                email,
                role,
                createdAt: Date.now()
            });
            await addDoc(collection(db, 'activityLog'), {
                action: `Added user: ${name}`,
                user: state.currentUser.name,
                timestamp: Date.now()
            });
        }
        closeModal();
        showNotification('User saved successfully');
    } catch (error) {
        console.error('Error saving user:', error);
        showNotification('Failed to save user: ' + error.message, null, true);
    }
};
}

function renderUsers() {
const list = document.getElementById('users-list');
list.innerHTML = '';
state.users.forEach(user => {
    const item = document.createElement('div');
    item.className = 'list-item';
    item.innerHTML = `
        <span>${user.name} (${user.role}) - ${user.email}</span>
        <div>
            <button class="btn-primary" onclick="showUserForm('${user.id}')">Edit</button>
            <button class="btn-danger" onclick="deleteUser('${user.id}')">Delete</button>
        </div>
    `;
    list.appendChild(item);
});
}

async function deleteUser(userId) {
if (userId === state.currentUser.id) {
    showNotification('Cannot delete current user', null, true);
    return;
}
try {
    await deleteDoc(doc(db, 'users', userId));
    // Note: Firebase Auth user deletion requires admin SDK, not possible client-side
    await addDoc(collection(db, 'activityLog'), {
        action: 'Deleted user',
        user: state.currentUser.name,
        timestamp: Date.now()
    });
    showNotification('User deleted successfully (Auth deletion requires admin action)');
} catch (error) {
    console.error('Error deleting user:', error);
    showNotification('Failed to delete user', null, true);
}
}

function renderAssignRoles() {
const list = document.getElementById('roles-list');
list.innerHTML = '';
state.users.forEach(user => {
    const item = document.createElement('div');
    item.className = 'list-item';
    item.innerHTML = `
        <span>${user.name} - ${user.email}</span>
        <select onchange="updateUserRole('${user.id}', this.value)">
            <option value="QA Member" ${user.role === 'QA Member' ? 'selected' : ''}>QA Member</option>
            <option value="Team Lead" ${user.role === 'Team Lead' ? 'selected' : ''}>Team Lead</option>
            <option value="Admin" ${user.role === 'Admin' ? 'selected' : ''}>Admin</option>
        </select>
    `;
    list.appendChild(item);
});
}

async function updateUserRole(userId, role) {
try {
    await updateDoc(doc(db, 'users', userId), { role });
    await addDoc(collection(db, 'activityLog'), {
        action: `Updated role of user ${state.users.find(u => u.id === userId).name} to ${role}`,
        user: state.currentUser.name,
        timestamp: Date.now()
    });
    showNotification('Role updated successfully');
} catch (error) {
    console.error('Error updating role:', error);
    showNotification('Failed to update role', null, true);
}
}

function calculateDashboardStats() {
const stats = {
    'My Projects': { projects: 0, pendingApprovals: 0, completedProjects: 0 }
};
if (state.currentUser.role === 'Team Lead' || state.currentUser.role === 'Admin') {
    stats['All Projects'] = { projects: 0, pendingApprovals: 0, completedProjects: 0 };
}

state.projectOverview.forEach(project => {
    const isMine = project.qaId === state.currentUser.id;
    if (isMine) {
        stats['My Projects'].projects++;
        if (project.tlApproval === 'Awaiting Approval') stats['My Projects'].pendingApprovals++;
        if (project.status === 'Completed') stats['My Projects'].completedProjects++;
    }
    if (state.currentUser.role === 'Team Lead' || state.currentUser.role === 'Admin') {
        stats['All Projects'].projects++;
        if (project.tlApproval === 'Awaiting Approval') stats['All Projects'].pendingApprovals++;
        if (project.status === 'Completed') stats['All Projects'].completedProjects++;
    }
});
return stats;
}

function updateUserAvatar() {
document.getElementById('user-name').textContent = state.currentUser.name;
document.getElementById('user-avatar').textContent = state.currentUser.name.charAt(0).toUpperCase();
}

function toggleSidebar() {
document.querySelector('.sidebar').classList.toggle('collapsed');
}

function sortTable(columnIndex) {
const tbody = document.querySelector('#project-overview-table');
const rows = Array.from(tbody.querySelectorAll('tr'));
const direction = state.sortDirection[columnIndex] === 'asc' ? 'desc' : 'asc';
state.sortDirection[columnIndex] = direction;

rows.sort((a, b) => {
    const aValue = a.cells[columnIndex].textContent;
    const bValue = b.cells[columnIndex].textContent;
    return direction === 'asc' 
        ? aValue.localeCompare(bValue) 
        : bValue.localeCompare(aValue);
});

tbody.innerHTML = '';
rows.forEach(row => tbody.appendChild(row));
}
    </script>
</body>
</html>
